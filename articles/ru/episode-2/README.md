![Image of this Article](https://raw.githubusercontent.com/totaki/graphql-learn/develop/articles/main.png)

Список эпизодов:
* [Эпизод 1](https://github.com/totaki/graphql-learn/tree/develop/articles/ru/episode-1/README.md)
* Эпизод 2

# GraphQL и Python. Эпизод 2

## Что нам для этог понадобится
1. Python 3
2. Tornado
3. Graphene
4. Docker вместе с docker-compose
5. GraphiQL
6. Nginx


Схема работы окружения для разработки будет следущая у нас поднимается nginx который проксирует
все на ноду, кроме запросов на /graphql который проксирует в наш бэкенд 


## Реализация на Python
На питон мы с вами будем реализовывать небольшую скрам доску. Базовые сущности у нас будут задачи, итерация и пользователи.

Задачи будут именть идентификатор, названия, описания, ответвсенного пользователя, итерация, статус и родителя
Пользователи в свою очередь будут иметь ник, задачи за которые пользователь отвественный

В первую очередь мы создадим наши абстракции 

Для начала мы сделаем хранилище для наших данных, я не буду использовать БД какую-либо, а сделаю просто классы которые
хранят в словаре с ключами int наши записи  


```python

class Record:
    
    def __init__(self, id_, type, data):
        pass

class Store:

    def __init__(self, *args, **kwargs):
        pass
       
    def get(self, id):
        pass
    
    def create(self, *args, **kwargs):
        pass
    
    def update(self, id, *args, **kwargs):
        pass
    
    def delete(self, id):
        pass
```

Теперь сделаем базовы классы:

```python
class User:
    
    """
    id: int
    name: str
    tasks: []
    """
    
    def get_tasks(self):
        pass
```

```python
class Iteration:

    """
    id: int
    start_date: datetime.date
    days: int
    tasks: []
    """
    def get_tasks(self):
        pass
    
    def get_stop_date(self):
        pass
```

```python
class Task:

    """
    id: int
    title: str
    description: str
    iteration: Iteration or None
    user: User or None
    parent: Task or None
    status: enum ['todo', 'inprogress', 'review', 'finish']
    """
```

Начнем с того что сделаем базу для нашей схемы
```python
class ScrumBoard:

    """
    backlog: [Task]
    dashboard: [Task]
    finish: [Task]
    """
    
    def get_backlog(self):
        pass
    
    def get_bashboard(self):
        pass
    
    def get_finish(self):
        pass
```

Будет у нас также 3 вида скопа, это бэклог (задачи без итерации), дашбоард (тут мы берем итерацию на текущий дату),
и финиш итерации которые на текущую дату завершенны


#  Попытка номер 2

В общем я попробовал пойти по обычному для себя пути, стал писать сначала пустые классы, что бы понять какие данные у меня
будут, потом стал писать для них атрибуты graphql и потом писать резолверы. Можно было бы отобразить это примерной схемой
## TODO: нарисовать схему
Но оказалось, что так у меня не получится, даже используя фабрики не получилось связать классы друг с другом, был вариант
переопределить базовые классы или сделать другие хаки, но по опыту могу сказать если возникает такое желание значит вы 
что-то делаете иначе. Потом я попробовал отобразить это в другой схемы, не классической, написал код который работал и делал
свою функцию, но опять же у меня осталось ощущение что это не совсем то как надо работать с graphql. И тут я решил пойти
3-им путем. Смоделить сначала юзерстори и отображение чтобы понять какие данные, в какой момент времени мне нужны.
И полчились следующие истори:

1. Первая страница, пользователь заходит и видит бэклог (список задач) и дашбоард (текущая итерация). В бэклог соотвественно мы должны видеть название задачи, её айди
и кому она назначена. В дашбоард у нас разбит на 4 статуса в каждом у нас список задач. Мы сможем с этой страницы добавлять 
задачи, открывать задачи и двигать задачи. Двигать задачи вперед мы можем как угодно, двигать назад со всем крофе финиш.
Притом с ревью двигается сразу на туду.
 
## Описание приложения, отличия от примера
## Написание схемы, тесты
## Написание endpoint, тесты
## IDE пример использованя


