![Image of this Article](https://raw.githubusercontent.com/totaki/graphql-learn/develop/articles/main.png)

Список эпизодов:
* [Эпизод 1](https://github.com/totaki/graphql-learn/tree/develop/articles/ru/episode-1/README.md)
* Эпизод 2

# GraphQL и Python. Эпизод 2

## Наше приложение
Во многих примерах вы можете найти приложения типа TODO, со списком задач и полем ввода. Как мне кажется оно не отображает
всего того что есть в **GraphQL**, поэтому я решил в качестве примера взять расширенный TODO. Если быть точнее это будет 
какое-то подобие scrum/agile доски, включающее users, tasks, backlog, iteration, relation tasks и workflow.

Для начала небольшое ТЗ:
1. Backlog. Это список задач, которые не вошли ни в одну итерацию. Из него можно удалить задачу, а также перенести в итерацию
текущего контекста.
2. Iteration. Включает в себя список задач в этой итерации, а также дату начала и окончания. Каждая итерация имеет длительность
равной одной недели. Для того чтобы перенести задачу из одной итерации в другую, сначала надо вернуть ее бэклог, и переключить
контекст.
3. Task. Задача имеет название, описание, итерацию, состояние, ответсвенного пользователя и задачу родителя. Может быть
в трех состояниях **todo**, **in_progress**, **review**, **finish**. Задачи могут двигатся вперед и назад.
4. User. Имеет только имя и список задач, которые ему назначенны.

В этом эпизоде мы не будем делать клиентскую часть, а воспользуемся специальной **IDE** для **GraphQL**.

## Что нам для этого понадобится
1. [Python 3.6](https://www.python.org/downloads/)
2. [Tornado](http://www.tornadoweb.org/en/stable/)
3. [Graphene](http://graphene-python.org/)
4. [Docker](https://www.docker.com/) вместе с [docker-compose](https://docs.docker.com/compose/)
5. [GraphiQL](https://github.com/graphql/graphiql)
6. [Nginx](https://nginx.ru/ru/)

Сама схема работы у нас будет незамысловатой.

![Image of this Article](https://raw.githubusercontent.com/totaki/graphql-learn/develop/articles/deploy_full_width.png)


Схема работы окружения для разработки будет следущая у нас поднимается nginx который проксирует
все на ноду, кроме запросов на /graphql который проксирует в наш бэкенд 


## Реализация на Python
На питон мы с вами будем реализовывать небольшую скрам доску. Базовые сущности у нас будут задачи, итерация и пользователи.

Задачи будут именть идентификатор, названия, описания, ответвсенного пользователя, итерация, статус и родителя
Пользователи в свою очередь будут иметь ник, задачи за которые пользователь отвественный

В первую очередь мы создадим наши абстракции 

Для начала мы сделаем хранилище для наших данных, я не буду использовать БД какую-либо, а сделаю просто классы которые
хранят в словаре с ключами int наши записи  


```python

class Record:
    
    def __init__(self, id_, type, data):
        pass

class Store:

    def __init__(self, *args, **kwargs):
        pass
       
    def get(self, id):
        pass
    
    def create(self, *args, **kwargs):
        pass
    
    def update(self, id, *args, **kwargs):
        pass
    
    def delete(self, id):
        pass
```

Теперь сделаем базовы классы:

```python
class User:
    
    """
    id: int
    name: str
    tasks: []
    """
    
    def get_tasks(self):
        pass
```

```python
class Iteration:

    """
    id: int
    start_date: datetime.date
    days: int
    tasks: []
    """
    def get_tasks(self):
        pass
    
    def get_stop_date(self):
        pass
```

```python
class Task:

    """
    id: int
    title: str
    description: str
    iteration: Iteration or None
    user: User or None
    parent: Task or None
    status: enum ['todo', 'inprogress', 'review', 'finish']
    """
```

Начнем с того что сделаем базу для нашей схемы
```python
class ScrumBoard:

    """
    backlog: [Task]
    dashboard: [Task]
    finish: [Task]
    """
    
    def get_backlog(self):
        pass
    
    def get_bashboard(self):
        pass
    
    def get_finish(self):
        pass
```

Будет у нас также 3 вида скопа, это бэклог (задачи без итерации), дашбоард (тут мы берем итерацию на текущий дату),
и финиш итерации которые на текущую дату завершенны


#  Попытка номер 2

В общем я попробовал пойти по обычному для себя пути, стал писать сначала пустые классы, что бы понять какие данные у меня
будут, потом стал писать для них атрибуты graphql и потом писать резолверы. Можно было бы отобразить это примерной схемой
## TODO: нарисовать схему
Но оказалось, что так у меня не получится, даже используя фабрики не получилось связать классы друг с другом, был вариант
переопределить базовые классы или сделать другие хаки, но по опыту могу сказать если возникает такое желание значит вы 
что-то делаете иначе. Потом я попробовал отобразить это в другой схемы, не классической, написал код который работал и делал
свою функцию, но опять же у меня осталось ощущение что это не совсем то как надо работать с graphql. И тут я решил пойти
3-им путем. Смоделить сначала юзерстори и отображение чтобы понять какие данные, в какой момент времени мне нужны.
И полчились следующие истори:

1. Первая страница, пользователь заходит и видит бэклог (список задач) и дашбоард (текущая итерация). В бэклог соотвественно мы должны видеть название задачи, её айди
и кому она назначена. В дашбоард у нас разбит на 4 статуса в каждом у нас список задач. Мы сможем с этой страницы добавлять 
задачи, открывать задачи и двигать задачи. Двигать задачи вперед мы можем как угодно, двигать назад со всем крофе финиш.
Притом с ревью двигается сразу на туду.
 
## Описание приложения, отличия от примера
## Написание схемы, тесты
## Написание endpoint, тесты
## IDE пример использованя


